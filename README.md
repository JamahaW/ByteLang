# **BYTELANG**

Интерпретируемый низкоуровневый язык программирования.

## Структура программы

Скомпилированный байткод - программа

Программа состоит из следующих основных частей:

- data - данные о программе (Версия байткода, индекс начала code)
- heap - Область хранения всех переменных
- code - Область, где подряд записываются выполняемые инструкции с их аргументами

## Типы файлов ByteLang

- `bls` — (ByteLang Source) - исходный байткод (обычный текстовый файл)
- `blc` — (ByteLang Compiled) - скомпилированный байткод (простой двоичный файл)
- `blp` — (ByteLang Package) - пакет инструкций (обычный текстовый файл)

## Примитивные типы данных:

Таблица соответствия ByteLang - тип C++

- `i8 - int8_t`
- `u8 - uint8_t`
- `i16 - int16_t`
- `u16 - uint16_t`
- `i32 - int32_t`
- `u32 - uint32_t`
- `i64 - int64_t`
- `u64 - uint64_t`
- `f32 - float`
- `f64 - double`

## Виды конфигурационных файлов

- Пакет инструкций (package) (blp) Имеет вид:

  Компилятор будет искать в папке packages
    - Каждая строка содержит запись: `<name> <T..>`
    - Для комментариев используется #
    - name - идентификатор
    - T - тип ByteLang ('*' после T значит, что инструкция принимает указатель и приведёт значение к этому типу)

  Например:

  ```bls
  print i32* # вывод человекочитаемого значения
  exit u8 # завершение программы
  goto u16
  ```

- Профиль виртуальной машины (profile) (json) Имеет вид:

  Компилятор будет искать в папке profiles

    - prog_len - максимальный размер программы (null или не указывать поле чтобы без ограничений)
    - ptr_prog - размер в байтах указателя инструкции, ограничивает prog_len
    - ptr_heap - размер в байтах указателя на кучу, ограничивает размер кучи
    - ptr_inst - размер в байтах индекса инструкции (имеется ввиду, что индекс - это указатель в массиве инструкций)
    - ptr_type - размер в байтах под данные типа переменной (Переменная в памяти храниться в виде структуры
      `{ptr_type, ptr_value}` ptr_value имеет тип и размер соответствующий ptr_type)

  Например:
  ```json
  {
    "prog_len": 512,
    "ptr_prog": 2,
    "ptr_heap": 1,
    "ptr_inst": 1,
    "ptr_type": 1
  }
  ```

- Параметры окружения (environment) (json) Имеет вид:

  Компилятор будет искать в папке environments
    - platform - идентификатор Параметров виртуальной машины
    - packages - список пакетов команд, которые реализованы в данной ВМ

  Например:
  ```json
  {
    "platform": "avr",
    "packages": [
      "base",
      "io",
      "stack",
      "math"
    ]
  }
  ```

## Грамматика

Синтаксическое дерево упрощено. Это линейная последовательность Statement

- `Statement = Directive_use | Instruction_call | Mark`
- `Directive_use = .<name>`
- `Instruction_call = <name> <args..>`
- `Mark = <name>:`

*Комментарий обозначается `'#'`

Вот фрагмент кода, удовлетворяющий данной грамматике

```bls
.use env_test

my_mark:

instr_test 123
```

Директивы

Директивы используются для операций над кодом во время компиляции

- `use <env_name>` - Использовать окружение env_name
    - Вызывается один раз, обычно самой первой строчкой
    - окружение представляет собой JSON файл такого вида:

- `ptr <T> <name> <value>` объявить указатель.\
  Пример: `.ptr i32 abc 12345 ; объявить указатель abc типа i32 с значением 12345`
    - T должен соответствовать одному из существующих типов
    - повторное объявление с существующим идентификатором недопустимо
    - значение value должно быть допустимым для типа данных указателя

- `def <name> <value>` Объявить макро константу.\
  Пример: `.def TIMER_MAX_MS 1200`
    - повторное объявление с существующим идентификатором недопустимо
    - Можно указывать выражение, но запрещается указывать данный идентификатор в операндах
    - В выражении в качестве операндов могут быть только константы

Инструкции

запись : `<name> <arg1> <arg2> ...`

Метки

Метки используются для обозначения определенных точек в коде.\
Формат метки: `<name>:`\
Пример:
`mark:`

# TODO

для функций придумать штуку, которая отправляет в стек кусок HEAP от 0 до размера всех переменных внутри функции
И в runtime размечать там переменные


Внедрить в платформу конфигурацию пакетов команд.
Сменить название директивы platform

TODO Продвинутый синтаксис, расчёт константных выражений


TODO отказаться от inline!!